import pygame,sys,math,random
from pygame.locals import *

pygame.init()
SCREEN_WIDTH = 640
SCREEN_HEIGHT = 480
SCREEN = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
SCREEN.fill((0,0,0))
pygame.display.set_caption("PurdyPong")
clock = pygame.time.Clock()



""" COMPONENTS """

class Position:
  def __init__(self, x, y):
    self.x = x
    self.y = y

class Size:
  def __init__(self, w, h):
    self.width = w
    self.height = h

class Velocity:
  def __init__(self, s, x, y):
    self.speed = s
    self.dirX = x
    self.dirY = y

class Controller:
  def __init__(self):
    self.isControllable = True

class Sound:
  def __init__(self, file):
#    self.sound = pygame.soundgetfile(...)
    pass



""" NODES """

class Moveable:
  def __init__(self, pos, vel):
    self.position = pos
    self.velocity = vel

class Renderable:
  def __init__(self, pos, size):
    self.position = pos
    self.size = size

class Audible:
  def __init__(self):
    pass



""" ENTITIES """

class Player:
  def __init__(self):
    self.size = Size(20,100)
    self.position = Position(20, (SCREEN_HEIGHT/2 - self.size.height/2))
    self.velocity = Velocity(20, None, None)

class Computer:
  def __init__(self):
    self.size = Size(20,100)
    self.position = Position((SCREEN_WIDTH - 20 - self.size.width), (SCREEN_HEIGHT/2 - self.size.height/2))
    self.velocity = Velocity(20, None, None)

class Ball:
  def __init__(self):
    self.size = Size(20,20)
    self.position = Position((SCREEN_WIDTH/2 - self.size.width/2), (SCREEN_HEIGHT/2 - self.size.height/2))
    self.velocity = Velocity(20, -1, -1)



""" SYSTEMS """

class InputSystem:
  def __init__(self, player):
    self.player = player
  def process(self, key):
    if key == K_UP:
      self.player.velocity.dirY = -1
    elif key == K_DOWN
      self.player.velocity.dirY = 1
    else:
      self.player.velocity.dirY = 0

class MovementSystem:
  def __init__(self, nodes):
    self.nodes = nodes
  def process(self):
    for n in self.nodes:
      n.position.x += n.velocity.x * n.velocity.speed
      n.position.y += n.velocity.y * n.velocity.speed

class RenderSystem:
  def __init__(self, nodes):
    self.nodes = nodes
  def process(self):
    for n in self.nodes:
      surf = pygame.Surface((n.size.width, n.size.height))
      surf.fill((255,255,255))
      #pygame.Surface.blit(surf, SCREEN, (n.position.x, n.position.y, n.size.width, n.size.height))
      pygame.draw.rect(SCREEN, (255,255,255), (n.position.x, n.position.y, n.size.width, n.size.height))



class NodeManager:
  def __init__(self, entities):
    self.moveables = []
    self.renderables = []
    for e in entities:
      if e.position and e.velocity:
        self.moveables.append(Moveable(e.position, e.velocity))
      if e.position and e.size:
        self.renderables.append(Renderable(e.position, e.size))



def main():
  player = Player()
  computer = Computer()
  ball = Ball()
  nm = NodeManager([player, computer, ball])
  is = InputSystem(player)
  ms = MovementSystem(nm.moveables)
  rs = RenderSystem(nm.renderables)
  print rs.nodes
  
  running = True
  while running:
    for event in pygame.event.get():
      if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):
        running = False
      elif event.type == KEYDOWN:
        is.process(event.key)
    ms.process()
    rs.process()
    pygame.display.update()
    clock.tick(30)

  pygame.quit()
  sys.exit()

if __name__ == "__main__": main()
